package com.mgmresorts.loyalty.service.impl;

import com.fasterxml.jackson.databind.json.JsonMapper;
import com.google.inject.Inject;
import com.google.inject.name.Named;
import com.mgmresorts.common.concurrent.Executor;
import com.mgmresorts.common.concurrent.Result;
import com.mgmresorts.common.config.Runtime;
import com.mgmresorts.common.errors.SystemError;
import com.mgmresorts.common.exception.AppException;
import com.mgmresorts.common.exception.Exceptions;
import com.mgmresorts.common.exec.Circuit;
import com.mgmresorts.common.function.HeaderBuilder;
import com.mgmresorts.common.logging.Logger;
import com.mgmresorts.common.utils.Dates;
import com.mgmresorts.common.utils.ThreadContext;
import com.mgmresorts.common.utils.ThreadContext.TransactionContext;
import com.mgmresorts.common.utils.Utils;
import com.mgmresorts.loyalty.data.to.balance.CustomerBalanceWrapperVisitor;
import com.mgmresorts.loyalty.data.to.balance.ICustomerBalanceResponseWrapper;
import com.mgmresorts.loyalty.data.to.balance.ICustomerBalanceWrapperVisitor;
import com.mgmresorts.loyalty.dto.customer.Balance;
import com.mgmresorts.loyalty.dto.customer.CustomerBalances;
import com.mgmresorts.loyalty.dto.services.BalancesResponse;
import com.mgmresorts.loyalty.errors.Errors;
import com.mgmresorts.loyalty.service.IBalanceService;
import com.mgmresorts.loyalty.service.IRcxService;
import com.mgmresorts.loyalty.task.balance.CustomerBalanceTask;
import com.mgmresorts.loyalty.task.balance.ICustomerBalanceTaskFactory;
import com.mgmresorts.rcxplatform.ParallelMode;
import com.mgmresorts.rcxplatform.RcxExecutorService;
import com.mgmresorts.rcxplatform.RcxPhase;
import com.mgmresorts.rcxplatform.pojo.GetMembersResponse;
import com.mgmresorts.rcxplatform.pojo.Member;
import com.mgmresorts.rcxplatform.pojo.Personalization;
import com.mgmresorts.rcxplatform.pojo.Purse;
import com.mgmresorts.rcxplatform.pojo.Tier;

import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

public class BalanceService implements IBalanceService {
    private final Logger logger = Logger.get(BalanceService.class);

    private final int rcxTimeout = Runtime.get().getInt("rcx.thread.time.out", 6000);
    private final int rcxPoolSize = Runtime.get().getInt("rcx.thread.pool.size", 10);
    private final int timeOut = Runtime.get().getInt("customer.balance.thread.time.out", 0);
    private final String defaultExpireDate = Runtime.get().getConfiguration("customer.balance.tier.expireDate", "2024-02-01T07:59:59.999");

    private final ExecutorService executorService = Executors.newFixedThreadPool(rcxPoolSize);
    private final Circuit circuit = Circuit.ofConfig("circuit.breaker.balance");
    private final JsonMapper jsonMapper = new JsonMapper();
    private final String defaultTierName = "Sapphire";
    private final String defaultNextTier = "Pearl";
    private final String defaultCreditToNextTier = "20000";

    @Inject
    private IRcxService rcxService;

    @Inject
    private RcxPhase rcxPhase;

    @Inject
    @Named("customer-balance")
    private Executor executor;

    @Inject
    private RcxExecutorService rcxExecutorService;

    /*
     * This factory is auto-generated by Guice. See the interface and Module class
     * to see how this is set up. This factory can generate any of the possible
     * CustomerBalanceTask (s).
     */
    @Inject
    private ICustomerBalanceTaskFactory taskFactory;

    public static final ZoneId ZONE_ID_UTC = ZoneId.of("UTC");

    /**
     * Circuit breaker wrapper for player balance.
     */
    public BalancesResponse getCustomerBalance(String stringPlayer, String stringSite) throws AppException {
        return circuit.flow(() -> getCustomerBalanceFull(stringPlayer, stringSite), SystemError.UNABLE_TO_CALL_BACKEND);
    }

    /**
     * The overall flow of the service.<br/>
     * The four tasks are created and executed on four separate threads. This
     * service waits at a barrier until all the threads have completed their tasks.
     * Then it loops through the results, placing the result objects that are in the
     * wrappers into the final overall JSON POJO. If one of the results returns an
     * error then it is immediately thrown. Note that all errors are logged where
     * they occur, so if multiple threads throw an error, those errors are all
     * logged, regardless of whether or not a particular error is thrown to the
     * calling class.
     */
    public BalancesResponse getCustomerBalanceFull(String stringPlayer, String stringSite) throws AppException {
        logger.trace("Player Balance Service has been invoked.");
        ICustomerBalanceWrapperVisitor wrapperVisitor = new CustomerBalanceWrapperVisitor();
        if (!Utils.isNumeric(stringPlayer) || !Utils.isNumeric(stringSite)) {
            logger.debug("One or more of the request parameters are invalid. Player ID: " + stringPlayer + ", Site ID: " + stringSite + ".");
            throw new AppException(Errors.INVALID_PATRON_ID, "One or more of the request parameters are invalid. Player ID: " + stringPlayer + ", Site ID: " + stringSite + ".");
        }

        Future<Double> futurePpd = null;
        Future<GetMembersResponse> futureRcxPlayerBalance = null;
        ParallelMode currentPhase = rcxPhase.getCurrentPhase();
        logger.info("[RCX] current Phase: [{}]", currentPhase);
        switch (currentPhase) {
            case PHASE_3_PARALLEL_NON_RCX:
            case PHASE_4_PARALLEL_RCX:
                logger.info("[RCX] Phase: [{}].  Calling rcx.db pendingPointsBalance and rcx.plat playerBalance...", currentPhase);
                futurePpd = rcxExecutorService.getPendingPlayerBalanceAsync(stringPlayer);
                futureRcxPlayerBalance = rcxExecutorService.getPlayerBalanceAsync(stringPlayer);
                break;
            case PHASE_5_FINAL:
                logger.info("[RCX] Phase: [{}].  Calling rcx playerBalance only...", currentPhase);
                futureRcxPlayerBalance = rcxExecutorService.getPlayerBalanceAsync(stringPlayer);
                break;
            case PHASE_1_OFF:
            case PHASE_2_BUFFER:
            default:
                logger.info("[RCX] Phase: [{}].  Calling rcx.db pendingPointsBalance only...", currentPhase);
                futurePpd = executorService.submit(() -> rcxService.rcxGetPendingPoints(stringPlayer));
                break;
        }

        final int player = Integer.parseInt(stringPlayer);
        final int site = Integer.parseInt(stringSite);

        final BalancesResponse balancesResponse = new BalancesResponse();
        final List<CustomerBalanceTask<?, ?>> tasks = new ArrayList<CustomerBalanceTask<?, ?>>();
        final TransactionContext copy = ThreadContext.getContext().get().copy();
        tasks.add(taskFactory.createBalanceTask(player, site, "balance", copy));
        tasks.add(taskFactory.createGiftPointsTask(player, site, "gift points", copy));

        if (currentPhase != ParallelMode.PHASE_5_FINAL) {
            logger.info("[RCX] Phase: [{}].  Calling tier Task...", currentPhase);
            tasks.add(taskFactory.createTierTask(player, site, "tier", copy));
        } else {
            logger.info("[RCX] Phase: [{}].  No longer calling tier Task...", currentPhase);
        }

        final Collection<Result<ICustomerBalanceResponseWrapper>> results = executor.invoke(tasks, timeOut);

        for (Result<ICustomerBalanceResponseWrapper> wrapperResult : results) {
            final Throwable throwable = wrapperResult.getThrowable();
            if (!Utils.anyNull(throwable)) {
                cancelFuture(futurePpd);
                cancelFuture(futureRcxPlayerBalance);

                throw new AppException(Exceptions.unwrapCode(throwable, true), throwable, "");
            }
            wrapperResult.getOutput().accept(wrapperVisitor);
        }
        balancesResponse.setCustomerBalances(wrapperVisitor.getCustomerBalances());
        balancesResponse.setHeader(HeaderBuilder.buildHeader());

        switch (currentPhase) {
            case PHASE_4_PARALLEL_RCX:
            case PHASE_5_FINAL:
                logger.info("[RCX] Phase: [{}].  Over-write values from rcx...", currentPhase);
                setRcxPlayerBalances(futureRcxPlayerBalance, balancesResponse);
                break;
            case PHASE_1_OFF:
            case PHASE_2_BUFFER:
            case PHASE_3_PARALLEL_NON_RCX:
            default:
                logger.info("[RCX] Phase: [{}].  Use pendingPointsBalance but not other values from rcx...", currentPhase);
                setRcxPendingBalance(futurePpd, balancesResponse);
                break;
        }

        return balancesResponse;
    }

    private void cancelFuture(Future future) {
        if (future != null) {
            try {
                future.cancel(true);
                logger.debug("Rcx call cancelled.");
            } catch (Exception e) {
                logger.info("Exception while cancelling reactorCX call, ignored");
            }
        }
    }

    private void setRcxPendingBalance(Future<Double> futurePendingBalance, BalancesResponse balancesResponse) {
        double pendingPointsBalance = 0.0;
        if (futurePendingBalance != null) {
            logger.info("[RCX-DB] set RCX pending points balance ");
            try {
                double futurePendingPointsBalance = futurePendingBalance.get(rcxTimeout, TimeUnit.MILLISECONDS);
                pendingPointsBalance = futurePendingPointsBalance >= 0.0 ? futurePendingPointsBalance : 0.0;
            } catch (Exception e) {
                logger.error("Exception happened during rcxGetPendingPoints: ", e);
            }
        }
        balancesResponse.getCustomerBalances().getBalance().setPendingPointsBalance(pendingPointsBalance);
    }

    protected void setRcxPlayerBalances(Future<GetMembersResponse> futureMembersResponse, BalancesResponse patronBalancesResponse) {
        if (futureMembersResponse != null) {
            logger.info("[RCX] Write RCX values to response...");
            GetMembersResponse rcxResponse = null;
            CustomerBalances patronBalances = patronBalancesResponse.getCustomerBalances();
            try {
                rcxResponse = futureMembersResponse.get(rcxTimeout, TimeUnit.MILLISECONDS);
                if (patronBalances.getTier() == null) {
                    // In rcx Phase5, tier will not exist
                    patronBalances.setTier(new com.mgmresorts.loyalty.dto.customer.Tier());
                }

                logger.info("[RCX] got responses...");
                Member rcxMainMember = rcxResponse.getMainMember();

                if (rcxMainMember != null) {
                    // set pending points balance from rcx
                    setResponseWithRcxPendingPointsBalance(patronBalances, rcxMainMember);

                    // set tier info from rcx
                    setResponseWithRcxTierInfo(patronBalances, rcxMainMember);

                    // set personalization info from rcx
                    setResponseWithRcxPersonalizationInfo(patronBalances, rcxResponse.getPersonalization());

                    // set comp balance info from rcx
                    setResponseWithRcxCompBalanceInfo(patronBalances, rcxResponse);
                }
            } catch (Exception e) {
                logger.info("[RCX] Error thrown:  Message: [{}]", e.getMessage());

                setDefaultTierValues(patronBalances);
            }
            logger.info("[RCX] Finished over-writing tier/balance values");
        }
    }

    public void setDefaultTierValues(CustomerBalances patronBalances) {

        com.mgmresorts.loyalty.dto.customer.Tier defaultTier = patronBalances.getTier() == null
            ? new com.mgmresorts.loyalty.dto.customer.Tier()
            : patronBalances.getTier();

        ZonedDateTime zdtNow = ZonedDateTime.now(ZONE_ID_UTC);

        defaultTier.setPlayerTierName(defaultTierName);
        defaultTier.setNextTier(defaultNextTier);
        defaultTier.setCreditToNextTier(defaultCreditToNextTier);
        defaultTier.setTierCredits(0);
        defaultTier.setAchievedDate(zdtNow);
        defaultTier.setEarnedDate(zdtNow);
        defaultTier.setExpireDate(Dates.toZonedDateTime(defaultExpireDate, ZONE_ID_UTC));

        patronBalances.setTier(defaultTier);
        patronBalances.getBalance().setPendingPointsBalance(0.000);
    }

    public void setResponseWithRcxTierInfo(CustomerBalances patronBalances, Member rcxMainMember) {
        logger.debug("setResponseWithRcxTierInfo: start");
        try {
            logger.info("[RCX] get tiers...count: [{}]", rcxMainMember.getTiers().size());
            Tier rcxMainTier = rcxMainMember.getTiers().get(0);

            com.mgmresorts.loyalty.dto.customer.Tier patronTier = patronBalances.getTier();
            logRcxValue("Tier.playerTierName", patronTier.getPlayerTierName(), rcxMainTier.getLevel().getName());
            patronTier.setPlayerTierName(rcxMainTier.getLevel().getName());

            Instant rcxAchievedOn = Instant.parse(rcxMainTier.getAchievedOn());
            ZonedDateTime rcxAchievedOnZdt = rcxAchievedOn.atZone(ZONE_ID_UTC);
            logRcxValue("Tier.achievedDate", patronTier.getAchievedDate(), rcxAchievedOnZdt);
            patronTier.setAchievedDate(rcxAchievedOnZdt);
            logRcxValue("Tier.earnedDate", patronTier.getEarnedDate(), rcxAchievedOnZdt);
            patronTier.setEarnedDate(rcxAchievedOnZdt);

            Instant rcxRequalsOn = Instant.parse(rcxMainTier.getRequalsOn());
            ZonedDateTime rcxRequalsOnZdt = rcxRequalsOn.atZone(ZONE_ID_UTC);
            logRcxValue("Tier.expiredDate", patronTier.getExpireDate(), rcxRequalsOnZdt);
            patronTier.setExpireDate(rcxRequalsOnZdt);

            logRcxValue("Tier.previousTier", patronTier.getPreviousTier(), rcxMainTier.getPrevLevelName());
            patronTier.setPreviousTier(rcxMainTier.getPrevLevelName());

        } catch (Exception err) {
            logger.error("Exception thrown in setResponseWithRcxTierInfo()", err);
        }
        logger.debug("setResponseWithRcxTierInfo: end");
    }

    public void setResponseWithRcxPersonalizationInfo(CustomerBalances patronBalances, Personalization personalization) {
        logger.debug("setResponseWithRcxPersonalizationInfo: start");
        try {
            com.mgmresorts.loyalty.dto.customer.Tier patronTier = patronBalances.getTier();

            logRcxValue("Tier.nextTier", patronTier.getNextTier(), personalization.getNextTier());
            patronTier.setNextTier(personalization.getNextTier());

            String rcxCreditsToNextTier = String.valueOf(personalization.getCreditsToNextTier());
            logRcxValue("Tier.creditToNextTier", patronTier.getCreditToNextTier(), rcxCreditsToNextTier);
            patronTier.setCreditToNextTier(rcxCreditsToNextTier);
        } catch (Exception err) {
            logger.error("Exception thrown in setResponseWithRcxPersonalizationInfo()", err);
        }
        logger.debug("setResponseWithRcxPersonalizationInfo: end");
    }

    public void setResponseWithRcxPendingPointsBalance(CustomerBalances patronBalances, Member rcxMainMember) {
        logger.debug("setResponseWithRcxPendingPointsBalance: start");
        try {
            Purse rcxRewardsPoints = rcxMainMember.getRewardsPoints();
            double rcxValuePendingPointsBalance = rcxRewardsPoints.getBalance() - rcxRewardsPoints.getAvailBalance()
                    - rcxMainMember.getDeferredDebits().getBalance();
            Balance patronBalance = patronBalances.getBalance();
            double patronPendingPointsBalance = patronBalance.getPendingPointsBalance() != null ? patronBalance.getPendingPointsBalance() : 0.0;
            logRcxValue("balance.pendingPointsBalance", patronPendingPointsBalance, rcxValuePendingPointsBalance);
            patronBalance.setPendingPointsBalance(rcxValuePendingPointsBalance);
        } catch (Exception err) {
            logger.error("Exception thrown in setResponseWithRcxPendingPointsBalanceInfo()", err);
        }
        logger.debug("setResponseWithRcxPendingPointsBalance: end");
    }

    public void setResponseWithRcxCompBalanceInfo(CustomerBalances patronBalances, GetMembersResponse rcxResponse) {
        logger.debug("setResponseWithRcxCompBalanceInfo: start");
        try {
            Member rcxLinkedMember = rcxResponse.getLinkedMember();
            double rcxLinkedTierCreditsAvailableBalance = 0.0;
            double rcxLinkedSecondCompBalance = 0.0;
            if (rcxLinkedMember != null) {
                rcxLinkedTierCreditsAvailableBalance = rcxLinkedMember.getTierCredits().getAvailBalance();

                double linkedSecondCompBalance = rcxLinkedMember.getRewardsPoints().getAvailBalance();
                rcxLinkedSecondCompBalance = linkedSecondCompBalance == 0.0 ? 0.0 : linkedSecondCompBalance / 100;
            }

            Member rcxMainMember = rcxResponse.getMainMember();
            if (rcxMainMember != null) {
                com.mgmresorts.loyalty.dto.customer.Tier patronTier = patronBalances.getTier();
                double rcxTierCredits = rcxMainMember.getTierCredits().getAvailBalance() + rcxLinkedTierCreditsAvailableBalance;
                logRcxValue("Tier.tierCredits", patronTier.getTierCredits(), rcxTierCredits);
                patronTier.setTierCredits((int) (rcxTierCredits));

                // ReactorCx returns secondCompBalance as Reward Points (cents) so need to divide by 100 to get dollar/cents value
                // (ie patron returned 65.40 for secondCompBalance; Rcx returns 6540 as AvailBalance;  Divide by 100 to be compatible
                Balance patronBalance = patronBalances.getBalance();
                Purse rcxRewardsPoints = rcxResponse.getMainMember().getRewardsPoints();
                double secondCompBalance = rcxRewardsPoints.getAvailBalance();
                double rcxSecondCompBalance = secondCompBalance == 0.0 ? 0.0 : secondCompBalance / 100;
                logRcxValue("balance.secondCompBalance", patronBalance.getSecondCompBalance(), rcxSecondCompBalance);
                patronBalance.setSecondCompBalance(rcxSecondCompBalance);

                double rcxSecondCompBalanceLinked = rcxSecondCompBalance + rcxLinkedSecondCompBalance;
                logRcxValue("balance.secondCompBalancedLinked", String.valueOf(patronBalance.getSecondCompBalanceLinked()),
                        String.valueOf(rcxSecondCompBalanceLinked));
                patronBalance.setSecondCompBalanceLinked(rcxSecondCompBalanceLinked);
            } else {
                logger.warn("[RCX] rcxMainMember is null");
            }
        } catch (Exception err) {
            logger.error("Exception thrown in setResponseWithRcxCompBalanceInfo()", err.getMessage(), err);
        }
        logger.debug("setResponseWithRcxCompBalanceInfo: end");
    }

    private void logRcxValue(String propertyName, Object originalValue, Object rcxValue) {
        try {
            if (originalValue == null) {
                originalValue = "NULL";
            }

            if (rcxValue == null) {
                rcxValue = "NULL";
            }

            String strOriginalValue = String.valueOf(originalValue);
            String strRcxValue = String.valueOf(rcxValue);

            String formatString = "[RCX] Property: [{}];  initial: [{}];  rcx: [{}]; equals: [{}]";
            boolean isEqual = strOriginalValue.equalsIgnoreCase(strRcxValue);
            if (isEqual) {
                logger.debug(formatString, propertyName, strOriginalValue, strRcxValue, isEqual);
            } else {
                logger.warn(formatString, propertyName, strOriginalValue, strRcxValue, isEqual);
            }
        } catch (Exception err) {
            logger.error("[RCX] Error in logRcxValue(property: [" + propertyName + "]): [" + err.getMessage() + "]", err);
        }
    }
}
